/*
 * elliptic_factory.cc
 * Copyright 2015 John Lawson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "elliptic_factory.h"

#include <cmath>

namespace ptope {
namespace elliptic_factory {
namespace {
const double sqrt2 = std::sqrt(2.0);
const double min_recip_sqrt2 = -sqrt2 / 2;
const double min_cos_pi_5 = -(1+std::sqrt(5))/4;
const double pi = 3.14159265358979323846264338327950288419716939937510582097494;

arma::mat e6() {
	arma::mat result = 
		{ { 1, -.5, 0, 0, 0, 0 },
			{-.5, 1, -.5, 0, 0, 0 },
			{ 0, -.5, 1, -.5, -.5, 0 },
			{ 0, 0, -.5, 1, 0, 0 },
			{ 0, 0, -.5, 0, 1, -.5 },
			{ 0, 0, 0, 0, -.5, 1 } };
	return result;
}
arma::mat e7() {
	arma::mat result = 
		{ { 1, -.5, 0, 0, 0, 0, 0 },
			{-.5, 1, -.5, 0, 0, 0, 0 },
			{ 0, -.5, 1, -.5, -.5, 0, 0 },
			{ 0, 0, -.5, 1, 0, 0, 0 },
			{ 0, 0, -.5, 0, 1, -.5, 0 },
			{ 0, 0, 0, 0, -.5, 1, -.5 },
			{ 0, 0, 0, 0, 0, -.5, 1 } };
	return result;
}
arma::mat e8() {
	arma::mat result = 
		{ { 1, -.5, 0, 0, 0, 0, 0, 0 },
			{-.5, 1, -.5, 0, 0, 0, 0, 0 },
			{ 0, -.5, 1, -.5, -.5, 0, 0, 0 },
			{ 0, 0, -.5, 1, 0, 0, 0, 0 },
			{ 0, 0, -.5, 0, 1, -.5, 0, 0 },
			{ 0, 0, 0, 0, -.5, 1, -.5, 0 },
			{ 0, 0, 0, 0, 0, -.5, 1, -.5 },
			{ 0, 0, 0, 0, 0, 0, -.5, 1 } };
	return result;
}
arma::mat f4() {
	arma::mat result =
	{ { 1, -.5, 0, 0 }, 
		{ -.5, 1, min_recip_sqrt2, 0 },
		{ 0, min_recip_sqrt2, 1, -.5 },
		{ 0, 0, -.5, 1 } };
	return result;
}
arma::mat g(const double label) {
	arma::mat result = 
	{ { 1, -std::cos(pi/label) },
		{-std::cos(pi/label), 1 } };
	return result;
}
arma::mat h3() {
	arma::mat result =
	{ { 1, min_cos_pi_5, 0 },
		{ min_cos_pi_5, 1, -.5 },
		{ 0, -.5, 1 } };
	return result;
}
arma::mat h4() {
	arma::mat result =
	{ { 1, min_cos_pi_5, 0, 0 },
		{ min_cos_pi_5, 1, -.5, 0 },
		{ 0, -.5, 1, -.5 },
		{ 0, 0, -.5, 1 } };
	return result;
}
}
/*
 * The general methods to generate types A, B and D break down each matrix into
 * blocks with (size + 1) elements in. These can be thought of as a column plus
 * extra entry. The matrix is then generated by filling each of these blocks in
 * turn.
 */
arma::mat type_a(const uint size) {
	arma::mat result(size, size);
	arma::uword index = 0;
	for(std::size_t i = 0; i < size-1; ++i) {
		result(index++) = 1;
		result(index++) = -.5;
		for(std::size_t j = 0; j < size-2; ++j) {
			result(index++) = 0;
		}
		result(index++) = -.5;
	}
	result(index) = 1;
	return result;
}
arma::mat type_b(const uint size) {
	arma::mat result(size, size);
	arma::uword index = 0;
	/* Set the initial block to be the edge with label 4 */
	result(index++) = 1;
	result(index++) = min_recip_sqrt2;
	for(std::size_t j = 0; j < size-2; ++j) {
		result(index++) = 0;
	}
	result(index++) = min_recip_sqrt2;
	/* Fill rest as with An */
	for(std::size_t i = 1; i < size-1; ++i) {
		result(index++) = 1;
		result(index++) = -.5;
		for(std::size_t j = 0; j < size-2; ++j) {
			result(index++) = 0;
		}
		result(index++) = -.5;
	}
	result(index) = 1;
	return result;
}
arma::mat type_d(const uint size) {
	if(size < 4) {
		return type_a(size);
	}
	arma::mat result(size, size);
	arma::uword index = 0;
	/* Set the 2 initial blocks to be the extra edges */
	result(index++) = 1;
	result(index++) = 0;
	result(index++) = -.5;
	for(std::size_t j = 0; j < size-3; ++j) {
		result(index++) = 0;
	}
	result(index++) = 0;
	/* Block 2 */
	result(index++) = 1;
	result(index++) = -.5;
	for(std::size_t j = 0; j < size-3; ++j) {
		result(index++) = 0;
	}
	result(index++) = -.5;
	result(index++) = -.5;
	/* Fill rest as with An */
	for(std::size_t i = 2; i < size-1; ++i) {
		result(index++) = 1;
		result(index++) = -.5;
		for(std::size_t j = 0; j < size-2; ++j) {
			result(index++) = 0;
		}
		result(index++) = -.5;
	}
	result(index) = 1;
	return result;
}
arma::mat type_e(const uint size) {
	switch(size) {
		case 6:
			return e6();
		case 7:
			return e7();
		case 8:
			return e8();
		default:
#ifdef PTOPE_DEBUG
			std::cerr << "elliptic_factory::type_e called with size " << size
				<< std::endl;
#endif
			return arma::mat();
	}
}
arma::mat type_f(const uint size) {
	switch(size) {
		case 4:
			return f4();
		default:
#ifdef PTOPE_DEBUG
			std::cerr << "elliptic_factory::type_f called with size " << size
				<< std::endl;
#endif
			return arma::mat();
	}
}
arma::mat type_g(const uint size, const uint label) {
	switch(size) {
		case 2:
			return g(label);
		default:
#ifdef PTOPE_DEBUG
			std::cerr << "elliptic_factory::type_g called with size " << size
				<< std::endl;
#endif
			return arma::mat();
	}
}
arma::mat type_h(const uint size) {
	switch(size) {
		case 3:
			return h3();
		case 4:
			return h4();
		default:
#ifdef PTOPE_DEBUG
			std::cerr << "elliptic_factory::type_h called with size " << size
				<< std::endl;
#endif
			return arma::mat();
	}
}
}
}

