/*
 * polytope_check.cc
 * Copyright 2015 John Lawson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "polytope_check.h"

namespace ptope {
PolytopeCheck::PolytopeCheck()
	: _visited_vertices( 0, 0 )
	, _edge_queue{}
	, m_dimension{ 0 }
{}
/*
 * The Gram matrix of a polytope contains all the information to determine
 * whether or not it is compact - which is really what this method is checking.
 * The basic idea is to start with one vertex and consider all sides at that
 * vertex. If the polytope is compact, then each of those sides will have a
 * second vertex somewhere along them. Do a breadth-first search along all such
 * edges from all vertices to determine whether there is any edge which does not
 * have a second vertex along it.
 *
 * It is a result of Vinberg that a k-dim face in the polytope corresponds to a
 * (d-k)x(d-k) submatrix of the gram matrix. Hence vertices are dxd submatrices
 * and edges are (d-1)x(d-1) submatrices. It is also true that for compact
 * polytopes each vertex must be elliptic, as the vertex is contained within
 * hyperbolic space, so the reflection group generated by reflections through
 * the planes intersecting at the vertex is finite. (If the vertex were ideal
 * the group is parabolic).
 *
 * Therefore this check starts with an elliptic dxd submatrix of the gram
 * matrix and considers all possible (d-1)x(d-1) submatrices of that submatrix.
 * These are the edges, so adding some other row/column of the gram matrix to
 * get a dxd matrix will give something that might possibly be a vertex. To
 * check whether it is or not it suffices to see if that matrix is elliptic. If
 * so then we have the other vertex along the side, otherwise try a different
 * row/column.
 *
 * Eventually either all edges have been checked and found to contain two
 * vertices so the matrix is a polytope, or one edge will be found to only
 * contain one vertex so the matrix is not a polytope.
 */
bool
PolytopeCheck::operator()(PolytopeCandidate const& p) {
	_visited_vertices.clear();
	while(!_edge_queue.empty()) _edge_queue.pop();
	if( m_dimension != p.real_dimension() ) {
		m_dimension = p.real_dimension();
		_visited_vertices = VectorSet<vector_elem_t>( m_dimension );
	}

	{// Does the set up for the initial vertex
		vector_t const init_v = initial_vertex(p);
		_visited_vertices.add(init_v);
		for(vector_index_t i = 0, max = init_v.size(); i < max; ++i) {
			_edge_queue.push( { 0, i } );
		}
	}
	arma::mat const& gram = p.gram();
	bool result = true;
	while(result && !_edge_queue.empty()) {
		Edge edge = _edge_queue.front();
		_edge_queue.pop();
		vector_elem_t const next_vert_ind = find_edge_end(edge, gram);
		if(next_vert_ind == no_vertex) {
			result =  false;
		} else {
			vector_t const new_vert = get_vertex_from_edge(edge, next_vert_ind);
			if(_visited_vertices.add(new_vert)) {
				vertex_index_t inserted_index = _visited_vertices.size() - 1;
				add_edges_from_vertex(new_vert, inserted_index, next_vert_ind);
			}
		}
	}
	return result;
}
PolytopeCheck::vector_elem_t
PolytopeCheck::find_edge_end(const Edge & edge, arma::mat const& gram) const {
	static arma::mat s_vertex_submat;
	static arma::uvec s_indices;
	static arma::uvec s_extra_vertex(1);
	static arma::uvec s_first_vertex;

	arma::uword const edge_size = m_dimension - 1;
	arma::uword const vertex_size = m_dimension;

	s_indices.set_size(vertex_size);
	s_first_vertex.set_size(vertex_size);
	s_vertex_submat.set_size(vertex_size, vertex_size);

	{
		auto const& vertex = priv_const_vertex_at( edge.vertex );
		arma::arrayops::convert( s_first_vertex.memptr(), vertex.memptr(),
				vertex_size );
	}
	arma::arrayops::copy( s_indices.memptr(), s_first_vertex.memptr(),
			edge.removed );
	arma::arrayops::copy( s_indices.memptr() + edge.removed,
			s_first_vertex.memptr() + edge.removed + 1, edge_size - edge.removed );

	arma::uword const last_entry = edge_size;

	s_vertex_submat.submat(0, 0, last_entry - 1, last_entry - 1) =
		gram.submat(s_indices.head(last_entry), s_indices.head(last_entry));

	vector_elem_t const removed_value = s_first_vertex( edge.removed );

	for(vector_elem_t i = 0, max = gram.n_cols; i < max; ++i) {
		if(i == removed_value) { continue; }
		// Each edge is sorted, so a binary search is better than std::find
		if( !std::binary_search(s_indices.begin(), s_indices.end() - 1, i) ) {
			s_extra_vertex(0) = i;
			s_indices(last_entry) = i;
			s_vertex_submat.col(last_entry) = gram.submat(s_indices, s_extra_vertex);
			s_vertex_submat.row(last_entry) = gram.submat(s_extra_vertex, s_indices);

			if(is_elliptic(s_vertex_submat)) { return i; }
		}
	}
	return no_vertex;
}
/* The initial vertex could be any elliptic subdiagram, however the way
 * PolytopeCandidates are constructed mean that the initial gram matrix would be
 * a good choice. The vectors corresponding to this matrix all have zeros in the
 * final coordinate, while any other vectors cannot. Hence this comes down to a
 * search for the vectors which have this zero. */
PolytopeCheck::vector_t
PolytopeCheck::initial_vertex(const PolytopeCandidate & p) const {
	const VectorFamily & vf = p.vector_family();
	const vector_index_t & last_val = p.real_dimension();

	vector_t result(last_val);

	vector_index_t result_ind = 0;
	for(arma::uword i = 0, max = vf.size();
			result_ind < last_val && i < max;
			++i) {
		auto vector = vf.unsafe_get(i);
		if(vector(last_val) == 0) {
			result(result_ind) = i;
			++result_ind;
		}
	}
	return result;
}
void
PolytopeCheck::add_edges_from_vertex( vector_t const& vertex,
		vertex_index_t const vertex_ind, vector_elem_t const exclude) {
	for(vector_index_t i = 0, max = m_dimension; i < max; ++i) {
		if(vertex(i) == exclude) continue;
		_edge_queue.push( { vertex_ind, i } );
	}
}
PolytopeCheck::vector_t
PolytopeCheck::get_vertex_from_edge(Edge const& edge,
		vector_elem_t const vertex_index) const {
	vector_index_t const vertex_size = m_dimension;
	vector_index_t const edge_size = m_dimension - 1;
	vector_t const old_vert = priv_const_vertex_at( edge.vertex );

	vector_t new_vert( vertex_size );

	// Copy the old vertex into the new one, missing out the removed entry.
	new_vert.head( edge.removed ) = old_vert.head( edge.removed );
	new_vert.subvec( edge.removed, edge_size - 1 ) = old_vert.subvec( edge.removed + 1, edge_size );
	new_vert(edge_size) = vertex_index;

	// Use rotate to move the inserted last value into the right/sorted position.
	// upper_bound gives the place to insert the value.
	auto last_edge_entry = new_vert.end() - 1;
	auto insert_place = std::upper_bound( new_vert.begin(), last_edge_entry, vertex_index );
	std::rotate( insert_place , last_edge_entry, new_vert.end() );
	return new_vert;
}
/* Simplifies what arma::chol computes. The upper triangle of
 * __elliptic_check_tmp will contain the actual cholesky decomp of mat. The
 * lower triangle contains junk that would otherwise be set to 0. We don't
 * actually care about the cholesky result here, just whether it can be
 * computed. */
bool
PolytopeCheck::has_chol(const arma::mat & mat) const {
	static arma::mat s_elliptic_check_tmp;
	s_elliptic_check_tmp = mat;
	static char uplo = 'U';
	arma::blas_int info = 0;
	arma::blas_int n = s_elliptic_check_tmp.n_rows;
	arma::lapack::potrf(&uplo, &n, s_elliptic_check_tmp.memptr(), &n, &info);
	return (info == 0);
}
}

