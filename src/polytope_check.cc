/*
 * polytope_check.cc
 * Copyright 2015 John Lawson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "polytope_check.h"

namespace ptope {
PolytopeCheck::PolytopeCheck()
	: _visited_vertices( 0, 0 )
	, _edge_queue{}
	, m_dimension{ 0 }
{}
/*
 * The Gram matrix of a polytope contains all the information to determine
 * whether or not it is compact - which is really what this method is checking.
 * The basic idea is to start with one vertex and consider all sides at that
 * vertex. If the polytope is compact, then each of those sides will have a
 * second vertex somewhere along them. Do a breadth-first search along all such
 * edges from all vertices to determine whether there is any edge which does not
 * have a second vertex along it.
 *
 * It is a result of Vinberg that a k-dim face in the polytope corresponds to a
 * (d-k)x(d-k) submatrix of the gram matrix. Hence vertices are dxd submatrices
 * and edges are (d-1)x(d-1) submatrices. It is also true that for compact
 * polytopes each vertex must be elliptic, as the vertex is contained within
 * hyperbolic space, so the reflection group generated by reflections through
 * the planes intersecting at the vertex is finite. (If the vertex were ideal
 * the group is parabolic).
 *
 * Therefore this check starts with an elliptic dxd submatrix of the gram
 * matrix and considers all possible (d-1)x(d-1) submatrices of that submatrix.
 * These are the edges, so adding some other row/column of the gram matrix to
 * get a dxd matrix will give something that might possibly be a vertex. To
 * check whether it is or not it suffices to see if that matrix is elliptic. If
 * so then we have the other vertex along the side, otherwise try a different
 * row/column.
 *
 * Eventually either all edges have been checked and found to contain two
 * vertices so the matrix is a polytope, or one edge will be found to only
 * contain one vertex so the matrix is not a polytope.
 */
bool
PolytopeCheck::operator()(PolytopeCandidate const& p) {
	static vector_t s_vertex;

	_not_elliptic.clear();
	_visited_vertices.clear();
	while(!_edge_queue.empty()) _edge_queue.pop();
	if( m_dimension != p.real_dimension() ) {
		m_dimension = p.real_dimension();
		_visited_vertices = VectorSet<vector_elem_t>( m_dimension );
		_not_elliptic = VectorSet<vector_elem_t>( m_dimension );
	}

	initial_vertex(p, s_vertex);
	_visited_vertices.add(s_vertex);
	for(vector_index_t i = 0, max = s_vertex.size(); i < max; ++i) {
		_edge_queue.emplace( 0, i );
	}

	arma::mat const& gram = p.gram();
	bool result = true;
	while(result && !_edge_queue.empty()) {
		Edge edge = _edge_queue.front();
		_edge_queue.pop();
		vector_elem_t const next_vert_ind = priv_edge_end(edge, gram, s_vertex);
		if(next_vert_ind == no_vertex) {
			result =  false;
		} else {
			if(_visited_vertices.add(s_vertex)) {
				vertex_index_t inserted_index = _visited_vertices.size() - 1;
				add_edges_from_vertex(s_vertex, inserted_index, next_vert_ind);
			}
		}
	}
	return result;
}
PolytopeCheck::vector_elem_t
PolytopeCheck::priv_edge_end( Edge const& edge, arma::mat const& gram,
		vector_t& vertex_out ) const {
	static arma::mat s_vertex_submat;
	static vector_t s_indices;

	arma::uword const edge_size = m_dimension - 1;
	arma::uword const vertex_size = m_dimension;

	s_indices.set_size(vertex_size);
	s_vertex_submat.set_size(vertex_size, vertex_size);

	vector_elem_t const * old_vertex_ptr = _visited_vertices.ptr_at( edge.vertex );
	arma::arrayops::copy( s_indices.memptr(), old_vertex_ptr, edge.removed );
	arma::arrayops::copy( s_indices.memptr() + edge.removed,
			old_vertex_ptr + edge.removed + 1, edge_size - edge.removed );

	// Construct the vertex submatrix, which later we will check to see if it is
	// elliptic. As the elliptic check knows the matrix is symmetric, it only ever
	// references the upper triangle of the matrix. Only setting this saves a
	// bunch of memory copies.
	priv_copy_upper_triangle_submat( s_vertex_submat.memptr(), gram.memptr(),
			s_indices, edge_size, vertex_size, gram.n_rows );

	arma::uword const last_entry = edge_size;
	vector_elem_t const removed_value = old_vertex_ptr[ edge.removed ];

	auto edge_begin = s_indices.begin();
	auto edge_end = s_indices.end() - 1;
	for(vector_elem_t i = 0, max = gram.n_cols; i < max; ++i) {
		if(i == removed_value) { continue; }
		// Each edge is sorted, so a binary search is better than std::find
		if( !std::binary_search(edge_begin, edge_end, i) ) {
			priv_vertex_from_edge( edge, i, vertex_out );
			if( _visited_vertices.contains( vertex_out )) { return i; }
			s_indices[last_entry] = i;
			priv_copy_submat_col( s_vertex_submat.colptr( last_entry ),
					gram.colptr( i ), s_indices, vertex_size );

			if(is_elliptic(s_vertex_submat)) {
				return i;
			}
		}
	}
	return no_vertex;
}
/* The initial vertex could be any elliptic subdiagram, however the way
 * PolytopeCandidates are constructed mean that the initial gram matrix would be
 * a good choice. The vectors corresponding to this matrix all have zeros in the
 * final coordinate, while any other vectors cannot. Hence this comes down to a
 * search for the vectors which have this zero. */
void
PolytopeCheck::initial_vertex(const PolytopeCandidate & p, vector_t& output) const {
	VectorFamily const& vf = p.vector_family();
	vector_index_t const last_val = p.real_dimension();
	output.set_size( last_val );

	vector_index_t result_ind = 0;
	for(arma::uword i = 0, max = vf.size();
			result_ind < last_val && i < max;
			++i) {
		auto vector = vf.get_ptr(i);
		if(vector[last_val] == 0) {
			output(result_ind) = i;
			++result_ind;
		}
	}
}
void
PolytopeCheck::priv_vertex_from_edge(Edge const& edge,
			vector_elem_t const vertex_index, vector_t& output) const {
	vector_index_t const edge_size = m_dimension - 1;

	// Copy the old vertex into the new one, missing out the removed entry.
	vector_elem_t const * old_vert_ptr = _visited_vertices.ptr_at( edge.vertex );
	arma::arrayops::copy( output.memptr(), old_vert_ptr, edge.removed );
	arma::arrayops::copy( output.memptr() + edge.removed,
			old_vert_ptr + edge.removed + 1, edge_size - edge.removed );
	output(edge_size) = vertex_index;

	// Use rotate to move the inserted last value into the right/sorted position.
	// upper_bound gives the place to insert the value.
	auto last_edge_entry = output.end() - 1;
	auto insert_place = std::upper_bound( output.begin(), last_edge_entry, vertex_index );
	std::rotate( insert_place , last_edge_entry, output.end() );
}
/* Simplifies what arma::chol computes. The upper triangle of
 * __elliptic_check_tmp will contain the actual cholesky decomp of mat. The
 * lower triangle contains junk that would otherwise be set to 0. We don't
 * actually care about the cholesky result here, just whether it can be
 * computed. */
bool
PolytopeCheck::has_chol(const arma::mat & mat) const {
	static arma::mat s_elliptic_check_tmp;
	s_elliptic_check_tmp = mat;
	static char uplo = 'U';
	arma::blas_int info = 0;
	arma::blas_int n = s_elliptic_check_tmp.n_rows;
	arma::lapack::potrf(&uplo, &n, s_elliptic_check_tmp.memptr(), &n, &info);
	return (info == 0);
}
}

